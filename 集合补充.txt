普通IO是以流的方式处理数据，NEWIO是以块的方式处理数据
文件字符操作流会自带缓存，默认大小是1024个字节，在缓存满后或手动刷新或关闭流的时候写入到文件里面
字节操作流默认每次操作会直接写入文件
buffered解决了频繁操作文件造成的性能减低，默认的缓存大小是8kb
try语句块会自动关闭流
如果一个类需要被序列化，那么该类必须实现serliable接口
什么时候对象需要被序列化呢？
1，把对象存储到物理介质中
2，对象需要在网络上传输时，也需要具备序列化功能
字节数组流是基于内存的操作流跟文件没有关系
 List 接口：有序，可以有null，可以重复
使用集合来存储多个不同的元素，那么在处理时会比较麻烦，在实际开发中不建议主要使用，我们应该在一个集合中存储相同的对象
ArrayList实现原理：1采用动态数组实现，默认构造方法创建一个空数组
2第一次添加元素，扩展元素为10 ，之后的扩充算法：原来数组大小+原来数组的一半
3不适合删除和插入操作
4为了防止数组动态扩充次数过多，建议创建ArrayList时，给定初始容量
5线程不安全，建议在单线程中使用
vector：1默认创建一个容量为10 的数组，采用动态对象数组实现
2容量扩充的算法，当增量为0时扩充为原来的两倍，当增量大于0时，扩充为原来大小加增量
3，不适合插入和删除操作
4线程安全，适合在多线程中使用，但是效率较低，
LindList：使用双向链表实现
2适合插入，删除操作
3线程不安全
在实际开发中我们如何选择list是具体实现？
1安全性问题
2是否频繁的插入删除操作(linkedlist)
3是否是存储后遍历
set接口是不包含重复元素的collection
无序的（不保证顺序）
hasSet：实现原理，基于哈希表（hasMap）不允许重复，可以有一个null元素，不保证顺序恒久不变，添加元素时把元素作为hasmap的键存储，hasmap的
value使用一个固定的object对象，排除重复是通过判断equal是否相等
哈希表的存储结构：数组+链表，数组里的每个元素以链表的方式存储
如何把对象储存到哈希表中？先计算对象的hascode值，在对数组的长度求余，来决定对象要存储到数组中的那个位置
treeset：有序的，基于treemap（二叉树数据结构）对象需要比较大小，通过对象比较器来实现
对象比较器还可以用来去除重复元素，如果自定义数据类，没有实现比较器接口，将无法添加到treeset集合中
如果要排序选择treeset
如果不要排序也不用保证顺序选择hashset
不要排序要保证顺序选择linkedhashset
1.8之后的foreach源代码也是用foreach数组遍历只不过更加便利且代码更加整洁
